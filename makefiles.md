#### resources

ascii version:\
https://www.gnu.org/software/make/manual/make.txt

the pdf version seems ok:\
https://www.gnu.org/software/make/manual/make.pdf

the html version is unwieldy:\
https://www.gnu.org/software/make/manual/make.html

A Makefile is a unix tool to compile software projects.

#### Why use makefiles?

Makefiles can detect which source files have changed and need to be recompiled.\
So not every file of the project has to be recompiled every time you make a change in one or two files.

#### installation

```
sudo pacman -S make
```

#### general shape of a makefile

A simple makefile consists of “rules” with the following shape:
```
target … : prerequisites …
        recipe
        …
        …
```

#### makefile for podman containers

```
touch makefile
```

It is important that you **need to use TABs** to indent: (spaces dont work)
```
build:
        podman build . -t mediawiki-1.40.0

run:
        podman run -d -p 8080:80 --name mediawiki-1.40.0-container mediawiki-1.40.0

clean:
        podman rmi -f mediawiki-1.40.0
```

Then you can build your container with `make build`, run it with `make run`, and remove the containers with `make clean`.

#### usage

If you just run the command `make` it will execute the first "target" in the file.

For a noop:
```
make -n
```

#### list all targets

You probably need `bash-completion` installed:
```
make <tab><tab>
```

#### run make with different CFLAGS
useful for debugging
```
make CFLAGS="-Wall -g"
```
but you need to clean your directory first (remove object files)

#### phony targets

When you have a makefile without strings behind the colons like above, it will work,\
but let's say you have a file called `run` in the directory and you do `make run`.\
That will not work:
```
make: 'run' is up to date.
```

You can put this infront of your build commands and it will work even when theres a file called `run`:
```
.PHONY: run
run:
	gcc -Wall ./src/*.c
	./a.out
```

#### targets

>A target is usually the name of a file that is generated by a program; examples of targets are executable or object files.\
A target can also be the name of an action to carry out, such as ‘clean’ (see Phony Targets).

#### make install

After having a compiled binary you might want to put the binary somewhere in your path.\
That is usually done with a `make install` or `sudo make install` like this:
```
.PHONY: install
install: a.out
	cp a.out /usr/local/bin/ics_analyzer
```

#### implicit rules

If there is no rule and/or recipe for a prerequisite, make will look for an implicit rule.

This will work and make will compile the source files `main.c` and `print_test.c` to .o files implicitly:
```
CC = gcc
CFLAGS = -Wall

executable: main.o print_test.o
        $(CC) $(CFLAGS) -o executable main.o print_test.o
```
It doesnt detect changes in header files.\
So you would need to write a custom rule and include the header files in the prerequisites.\
But at least you can ommit the recipe.

For linking it will only work if the name of the executable is the same as one of the object files.\
For example `main`:
```
CC = gcc
CFLAGS = -Wall

main: main.o print_test.o
```

But still you have the problem with the header files.

A structure like this works even for changes of the header files:
```
CC = gcc
CFLAGS = -Wall

main: main.o print_test.o

main.o: main.c

print_test.o: print_test.c print_test.h

.PHONY: clean
clean:
        -rm *.o executable
```

#### TODO: makefile for bigger projects

How to construct a "proper" makefile with first creating all the object files and then linking everything to a binary?

Having a makefile above your `src/` dir makes writing the makefile too stressful, because you have to include the path all the time.\
I think its better to have the makefile in the `src` directory with all the source files and then maybe have a second makefile in the top level directory that builds or includes the other makefile.

creating a variable for the object files will not work, because they dont exist at the time you run make:\
https://www.gnu.org/software/make/manual/make.html#Variables-Simplify

Use tips from chatgpt:
> Auto-Generating Object Files: Instead of explicitly listing each object file, you can automatically generate them using substitution functions. For instance: OBJECTS := $(SOURCES:.c=.o).
> Automate Source Discovery: You can use wildcard patterns to automatically discover source files in your project directory. For example: SOURCES := $(wildcard src/*.c).
> Use Build Systems: Consider using build system tools like CMake or Meson. They abstract away much of the complexity of writing Makefiles and can generate them for you based on a configuration file.

## examples

#### simple example with two source files

This will only recompile source files that have actually changed, \
but it will not recompile changes in header files.
```
countdown: main.o play_raw_audio.o
	gcc main.o play_raw_audio.o -o countdown -lpulse-simple

main.o: main.c
	gcc -Wall -c main.c

play_raw_audio.o: play_raw_audio.c
	gcc -Wall -c play_raw_audio.c

.PHONY:install
install:
	cp a.out /usr/local/bin/countdown

.PHONY:uninstall
uninstall:
	rm /usr/local/bin/countdown

.PHONY: clean
clean:
	-rm *.o countdown
```

#### example with wildcards

This way you don't have to list every source file manually:
```
# List of all source files (assuming they're all in the same directory)
SRC_FILES = $(wildcard *.c)

# Generate a list of object files by replacing the .c extension with .o
OBJ_FILES = $(SRC_FILES:.c=.o)

ics_analyzer: $(OBJ_FILES)
	gcc -Wall $(OBJ_FILES) -o ics_analyzer

$(OBJ_FILES): $(SRC_FILES)
	gcc -Wall -c $(SRC_FILES)
```
But this will recompile all source files even if just one source file changed.

#### example that will recompile also header changes

```
# List of all source files (assuming they're all in the same directory)
SRC_FILES = $(wildcard *.c)

# Generate a list of object files by replacing the .c extension with .o
OBJ_FILES = $(SRC_FILES:.c=.o)

ics_analyzer: $(OBJ_FILES)
	gcc -Wall $(OBJ_FILES) -o ics_analyzer

# Rule to compile C source files to object files
%.o: %.c %.h
	gcc -c $< -o $@
```
It uses special variables of make.

#### cli args for Makefiles

This worked.
```
make myvar="foooo"
```

```
all:
	echo "${myvar}"
```

## syntax

#### @ symbol

Usually all "recipes"/commands will be printed to stdout before executing them.\
Put a `@` infront of a "recipe"/command, so that the command will run but not be displayed on the cli.

Useful if you put `echo` commands in your recipes.

#### - symbol

In a recipe:
```
- rm *.o
```
the `-` will make sure, that the makefile continues even if the command failed \
(for example when there are not object files to delete).
