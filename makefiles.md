https://www.gnu.org/software/make/manual/make.html

A Makefile is a unix tool to compile software projects.

#### Why use makefiles?

Makefiles can detect which source files have changed and need to be recompiled.\
So not every file of the project has to be recompiled every time you make a change in one or two files.

#### installation

```
sudo pacman -S make
```

#### general shape of a makefile

A simple makefile consists of “rules” with the following shape:
```
target … : prerequisites …
        recipe
        …
        …
```

#### makefile for podman containers

```
touch makefile
```

It is important that you **need to use TABs** to indent: (spaces dont work)
```
build:
        podman build . -t mediawiki-1.40.0

run:
        podman run -d -p 8080:80 --name mediawiki-1.40.0-container mediawiki-1.40.0

clean:
        podman rmi -f mediawiki-1.40.0
```

Then you can build your container with `make build`, run it with `make run`, and remove the containers with `make clean`.

#### make

If you just run the command `make` it will execute the first "target" in the file.

#### phony targets

When you have a makefile without strings behind the colons like above, it will work,\
but let's say you have a file called `run` in the directory and you do `make run`.\
That will not work:
```
make: 'run' is up to date.
```

You can put this infront of your build commands and it will work even when theres a file called `run`:
```
.PHONY: run
run:
	gcc -Wall ./src/*.c
	./a.out
```

#### targets

>A target is usually the name of a file that is generated by a program; examples of targets are executable or object files.\
A target can also be the name of an action to carry out, such as ‘clean’ (see Phony Targets).

#### make install

After having a compiled binary you might want to put the binary somewhere in your path.\
That is usually done with a `make install` or `sudo make install` like this:
```
.PHONY: install
install: a.out
	cp a.out /usr/local/bin/ics_analyzer
```

#### TODO: makefile for bigger projects

How to construct a "proper" makefile with first creating all the object files and then linking everything to a binary?

Having a makefile above your `src/` dir makes writing the makefile too stressful, because you have to include the path all the time.\
I think its better to have the makefile in the `src` directory with all the source files and then maybe have a second makefile in the top level directory that builds or includes the other makefile.

You should definatelly create a variable for your object files like this:\
https://www.gnu.org/software/make/manual/make.html#Variables-Simplify

Use tips from chatgpt:
> Auto-Generating Object Files: Instead of explicitly listing each object file, you can automatically generate them using substitution functions. For instance: OBJECTS := $(SOURCES:.c=.o).
> Automate Source Discovery: You can use wildcard patterns to automatically discover source files in your project directory. For example: SOURCES := $(wildcard src/*.c).
> Use Build Systems: Consider using build system tools like CMake or Meson. They abstract away much of the complexity of writing Makefiles and can generate them for you based on a configuration file.

## syntax

#### @ symbol

Usually all "recipes"/commands will be printed to stdout before executing them.\
Put a `@` infront of a "recipe"/command, so that the command will run but not be displayed on the cli.

Useful if you put `echo` commands in your recipes.
